#include "../root_signature.hlsli"
#include "../interlop.hlsli"
#include "../Include/math.hlsli"

[RootSignature(BINDLESS_ROOT_SIGNATURE)]
float4 PS_DebugDrawLine(in float4 position: SV_Position, in float4 color: COLOR0) : SV_TARGET
{
  return color;
}

float sdf_sphere(float3 sphere_center, float sphere_radius, float3 position)
{
  return length(position - sphere_center) - sphere_radius;
}

float sdf_eval(DebugSdf sdf, float3 position)
{
  if (sdf.type == kSdfTypeSphere || sdf.type == kSdfTypeSphericalHarmonic)
  {
    return sdf_sphere(sdf.position, sdf.radius, position);
  }
  else
  {
    return -1.0;
  }
}

// https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/
float3 aces_rec2020_1000nits_odt(float3 x)
{
  float a = 15.8f;
  float b = 2.12f;
  float c = 1.2f;
  float d = 5.92f;
  float e = 1.9f;
  return (x * (a * x + b)) / (x * (c * x + d) + e);
}

float3 linear_to_pq(float3 rgb)
{
  rgb      /= 100.0f;
  float m1  = 2610.0 / 4096.0 / 4;
  float m2  = 2523.0 / 4096.0 * 128;
  float c1  = 3424.0 / 4096.0;
  float c2  = 2413.0 / 4096.0 * 32;
  float c3  = 2392.0 / 4096.0 * 32;
  float3 Lp = pow(rgb, m1);
  return pow((c1 + c2 * Lp) / (1 + c3 * Lp), m2);
}

ConstantBuffer<DebugSdfDrawSrt> g_DebugDrawSdfSrt : register(b0);

[RootSignature(BINDLESS_ROOT_SIGNATURE)]
float4 PS_DebugDrawSdf(in float4 position: SV_Position, in float3 ray_dir: RayDirection, in uint instance_id: InstanceID) : SV_TARGET
{
  float3 ray_origin = g_ViewportBuffer.camera_world_pos.xyz;

  StructuredBuffer<DebugSdf> sdf_buffer = DEREF(g_DebugDrawSdfSrt.debug_sdf_buffer);
  DebugSdf sdf = sdf_buffer[instance_id % kDebugMaxSdfs];
  #define kMaxSdfDistance (50)
  #define kMinSdfDistance (0.01)

  float d = 0.0;
  for (uint i = 0; i < 64; i++)
  {
    d += sdf_eval(sdf, ray_origin + ray_dir * d);
    if (d < kMinSdfDistance || d > kMaxSdfDistance)
    {
      break;
    }
  }

  if (d > kMaxSdfDistance)
  {
    discard;
    return 0.0;
  }

  float3 hit    = ray_origin + ray_dir * d;

  if (sdf.type == kSdfTypeSphericalHarmonic)
  {
    half3  normal  = (half3)normalize(hit - sdf.position);

    float3 diffuse = SH::CalculateIrradiance(sdf.luminance, normal) * 0.8f / kPI;
    return float4(linear_to_pq(aces_rec2020_1000nits_odt(diffuse)), 1.0);
  }
  else
  {
    return float4(sdf.color, 1.0);
  }

}
